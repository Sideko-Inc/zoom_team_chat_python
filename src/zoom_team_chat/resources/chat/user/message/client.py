"""File Generated by Sideko (sideko.dev)"""

from zoom_team_chat.utils.client_wrapper import AsyncClientWrapper, SyncClientWrapper
import typing
from zoom_team_chat.utils.request_options import RequestOptions, default_request_options
from zoom_team_chat.utils.query_params import encode_query_param, QueryParamTypes
import typing_extensions
from zoom_team_chat.types.chat.user.message import params, models
from zoom_team_chat.utils.request_body import to_encodable


class MessageClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper
        # register sync resources (keep comment for code generation)

    # register sync api methods (keep comment for code generation)
    def update(
        self,
        *,
        data: typing.Optional[params.PutChatUsersUserIdMessagesMessageIdBody] = None,
        user_id: str,
        message_id: str,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> None:
        """
        Edits a chat message that you previously sent to either a contact or a channel in Zoom.

        It provides the ID of the message as the value of the `messageId` parameter. You can get the ID from the [List User's Chat Messages](https://developers.zoom.us/docs/api/rest/reference/chat/methods/#operation/getChatMessages) API. Additionally, as a query parameter, you must provide either the contact's **email address** of the contact or the **Channel ID** of the channel where the message was sent.

        For user-level apps, pass [the `me` value](https://marketplace.zoom.us/docs/api-reference/using-zoom-apis#mekeyword) instead of the `userId` parameter.

        **Note:** For an **account-level** [OAuth app](https://marketplace.zoom.us/docs/guides/getting-started/app-types/create-oauth-app), you can only use this API on behalf of a user who is assigned with a [role](https://support.zoom.us/hc/en-us/articles/115001078646-Using-role-management#:~:text=Each%20user%20in%20a%20Zoom,owner%2C%20administrator%2C%20or%20member.&amp;text=Role%2Dbased%20access%20control%20enables,needs%20to%20view%20or%20edit.) that has the **Edit** permission for **Chat Messages**.



        **Scopes:** `chat_message:write`,`chat_message:write:admin`

        **Granular Scopes:** `team_chat:update:user_message`,`team_chat:update:user_message:admin`

        **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `MEDIUM`
        """
        # start -- build request data (keep comment for code generation)
        _json = to_encodable(
            item=data,
            dump_with=params._SerializerPutChatUsersUserIdMessagesMessageIdBody,
        )
        # end -- build request data (keep comment for code generation)

        # start -- send sync request (keep comment for code generation)
        return self._client_wrapper.request(
            method="PUT",
            path=f"/chat/users/{user_id}/messages/{message_id}",
            auth_names=["openapi_authorization", "openapi_oauth"],
            json=_json,
            cast_to=None,
            request_options=request_options or default_request_options(),
        )
        # end -- send sync request (keep comment for code generation)

    def send(
        self,
        *,
        data: typing.Optional[params.PostChatUsersUserIdMessagesBody] = None,
        user_id: str,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> models.PostChatUsersUserIdMessagesResponse:
        """
        Sends chat messages to a user in your contact list or to a [channel](https://support.zoom.us/hc/en-us/articles/200912909-Getting-Started-With-Channels-Group-Messaging-) of which you are a member.
        For user-level apps, pass [the `me` value](https://marketplace.zoom.us/docs/api-reference/using-zoom-apis#mekeyword) instead of the `userId` parameter.

        - To send a message to a contact, provide the contact's email address in the `to_contact` field.
        - To send a message to a channel, provide the channel's ID in the `to_channel` parameter.



        **Scopes:** `chat_message:write`,`chat_message:write:admin`

        **Granular Scopes:** `team_chat:write:user_message`,`team_chat:write:user_message:admin`

        **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `MEDIUM`
        """
        # start -- build request data (keep comment for code generation)
        _json = to_encodable(
            item=data, dump_with=params._SerializerPostChatUsersUserIdMessagesBody
        )
        # end -- build request data (keep comment for code generation)

        # start -- send sync request (keep comment for code generation)
        return self._client_wrapper.request(
            method="POST",
            path=f"/chat/users/{user_id}/messages",
            auth_names=["openapi_authorization", "openapi_oauth"],
            json=_json,
            cast_to=models.PostChatUsersUserIdMessagesResponse,
            request_options=request_options or default_request_options(),
        )
        # end -- send sync request (keep comment for code generation)

    def mark_status(
        self,
        *,
        data: typing.Optional[
            params.PatchChatUsersUserIdMessagesMessageIdStatusBody
        ] = None,
        user_id: str,
        message_id: str,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> None:
        """
        Marks a chat message as read or unread. For user-level apps, pass [the `me` value](https://marketplace.zoom.us/docs/api-reference/using-zoom-apis#mekeyword) instead of the `userId` parameter.

        **Note:**

        For an [account-level OAuth app](https://marketplace.zoom.us/docs/guides/getting-started/app-types/create-oauth-app), this API can only be used on behalf of a [user assigned to a role](https://support.zoom.us/hc/en-us/articles/115001078646-Using-role-management) with the &quot;**Edit**&quot; permission for **Chat Messages**.



        **Scopes:** `chat_message:write`,`chat_message:write:admin`

        **Granular Scopes:** `team_chat:update:message_status`,`team_chat:update:message_status:admin`

        **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Medium`
        """
        # start -- build request data (keep comment for code generation)
        _json = to_encodable(
            item=data,
            dump_with=params._SerializerPatchChatUsersUserIdMessagesMessageIdStatusBody,
        )
        # end -- build request data (keep comment for code generation)

        # start -- send sync request (keep comment for code generation)
        return self._client_wrapper.request(
            method="PATCH",
            path=f"/chat/users/{user_id}/messages/{message_id}/status",
            auth_names=["openapi_authorization", "openapi_oauth"],
            json=_json,
            cast_to=None,
            request_options=request_options or default_request_options(),
        )
        # end -- send sync request (keep comment for code generation)

    def react(
        self,
        *,
        data: typing.Optional[
            params.PatchChatUsersUserIdMessagesMessageIdEmojiReactionsBody
        ] = None,
        user_id: str,
        message_id: str,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> None:
        """
        Adds or removes an emoji to a chat message.

        For an **account-level** [OAuth app](https://marketplace.zoom.us/docs/guides/getting-started/app-types/create-oauth-app), this API can only be used on behalf of a user who is assigned with a [role](https://support.zoom.us/hc/en-us/articles/115001078646-Using-role-management#:~:text=Each%20user%20in%20a%20Zoom,owner%2C%20administrator%2C%20or%20member.&amp;text=Role%2Dbased%20access%20control%20enables,needs%20to%20view%20or%20edit.) that has the **Edit** permission for **Chat Messages**.



        **Scopes:** `chat_message:write`,`chat_message:write:admin`

        **Granular Scopes:** `team_chat:update:message_emoji`,`team_chat:update:message_emoji:admin`

        **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Medium`
        """
        # start -- build request data (keep comment for code generation)
        _json = to_encodable(
            item=data,
            dump_with=params._SerializerPatchChatUsersUserIdMessagesMessageIdEmojiReactionsBody,
        )
        # end -- build request data (keep comment for code generation)

        # start -- send sync request (keep comment for code generation)
        return self._client_wrapper.request(
            method="PATCH",
            path=f"/chat/users/{user_id}/messages/{message_id}/emoji_reactions",
            auth_names=["openapi_authorization", "openapi_oauth"],
            json=_json,
            cast_to=None,
            request_options=request_options or default_request_options(),
        )
        # end -- send sync request (keep comment for code generation)

    def get_thread(
        self,
        *,
        user_id: str,
        message_id: str,
        from_query: str,
        limit: typing.Optional[int] = None,
        need_attachment: typing.Optional[bool] = None,
        need_emoji: typing.Optional[bool] = None,
        need_main_message: typing.Optional[bool] = None,
        sort: typing.Optional[typing_extensions.Literal["desc", "asc"]] = None,
        to: typing.Optional[str] = None,
        to_channel: typing.Optional[str] = None,
        to_contact: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> models.GetChatUsersUserIdMessagesMessageIdThreadResponse:
        """
        Retrieves all messages under a thread. For user-level apps, pass the `me` value instead of the `userId` parameter.

        **Scopes:** `chat_message:read`,`chat_message:read:admin`

        **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `MEDIUM`
        """
        # start -- build request data (keep comment for code generation)
        _query: typing.Dict[str, QueryParamTypes] = {}
        _query["from"] = encode_query_param(from_query, False)
        if limit is not None:
            _query["limit"] = encode_query_param(limit, False)
        if need_attachment is not None:
            _query["need_attachment"] = encode_query_param(need_attachment, False)
        if need_emoji is not None:
            _query["need_emoji"] = encode_query_param(need_emoji, False)
        if need_main_message is not None:
            _query["need_main_message"] = encode_query_param(need_main_message, False)
        if sort is not None:
            _query["sort"] = encode_query_param(sort, False)
        if to is not None:
            _query["to"] = encode_query_param(to, False)
        if to_channel is not None:
            _query["to_channel"] = encode_query_param(to_channel, False)
        if to_contact is not None:
            _query["to_contact"] = encode_query_param(to_contact, False)
        # end -- build request data (keep comment for code generation)

        # start -- send sync request (keep comment for code generation)
        return self._client_wrapper.request(
            method="GET",
            path=f"/chat/users/{user_id}/messages/{message_id}/thread",
            auth_names=["openapi_authorization", "openapi_oauth"],
            query_params=_query,
            cast_to=models.GetChatUsersUserIdMessagesMessageIdThreadResponse,
            request_options=request_options or default_request_options(),
        )
        # end -- send sync request (keep comment for code generation)

    def get(
        self,
        *,
        user_id: str,
        message_id: str,
        download_file_formats: typing.Optional[
            typing_extensions.Literal["audio/mp4"]
        ] = None,
        to_channel: typing.Optional[str] = None,
        to_contact: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> models.GetChatUsersUserIdMessagesMessageIdResponse:
        """
        Returns a chat message previously sent to a contact or a channel. For user-level apps, pass [the `me` value](https://marketplace.zoom.us/docs/api-reference/using-zoom-apis#mekeyword) instead of the `userId` parameter.

        You must provide one of the following query parameters:

        * `to_contact` &mdash; The email address of the Zoom contact to whom you sent the message.
        * `to_channel` &mdash; The ID of the Zoom channel where you sent the message.



        **Scopes:** `chat_message:write:admin`,`chat_message:read`,`chat_message:write`,`chat_message:read:admin`

        **Granular Scopes:** `team_chat:read:user_message`,`team_chat:read:user_message:admin`

        **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `MEDIUM`
        """
        # start -- build request data (keep comment for code generation)
        _query: typing.Dict[str, QueryParamTypes] = {}
        if download_file_formats is not None:
            _query["download_file_formats"] = encode_query_param(
                download_file_formats, False
            )
        if to_channel is not None:
            _query["to_channel"] = encode_query_param(to_channel, False)
        if to_contact is not None:
            _query["to_contact"] = encode_query_param(to_contact, False)
        # end -- build request data (keep comment for code generation)

        # start -- send sync request (keep comment for code generation)
        return self._client_wrapper.request(
            method="GET",
            path=f"/chat/users/{user_id}/messages/{message_id}",
            auth_names=["openapi_authorization", "openapi_oauth"],
            query_params=_query,
            cast_to=models.GetChatUsersUserIdMessagesMessageIdResponse,
            request_options=request_options or default_request_options(),
        )
        # end -- send sync request (keep comment for code generation)

    def list(
        self,
        *,
        user_id: str,
        date: typing.Optional[str] = None,
        download_file_formats: typing.Optional[
            typing_extensions.Literal["audio/mp4"]
        ] = None,
        exclude_child_message: typing.Optional[bool] = None,
        from_query: typing.Optional[str] = None,
        include_deleted_and_edited_message: typing.Optional[bool] = None,
        next_page_token: typing.Optional[str] = None,
        page_size: typing.Optional[int] = None,
        search_key: typing.Optional[str] = None,
        search_type: typing.Optional[
            typing_extensions.Literal["message", "file"]
        ] = None,
        to: typing.Optional[str] = None,
        to_channel: typing.Optional[str] = None,
        to_contact: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> models.GetChatUsersUserIdMessagesResponse:
        """
        Returns a list of chat messages and shared files between a user and an individual contact, or a chat channel. For user-level apps, pass [the `me` value](https://developers.zoom.us/docs/api/rest/using-zoom-apis/#the-me-keyword) instead of the `userId` parameter.

        **Note:** For an [account-level OAuth app](https://developers.zoom.us/docs/integrations/create/), this API can only be used on behalf of a [user assigned to a role](https://support.zoom.us/hc/en-us/articles/115001078646-Using-role-management) with the **Edit** permission for **Chat Messages**.



        **Scopes:** `chat_message:write:admin`,`chat_message:read`,`chat_message:write`,`chat_message:read:admin`

        **Granular Scopes:** `team_chat:read:list_user_messages`,`team_chat:read:list_user_messages:admin`

        **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `MEDIUM`
        """
        # start -- build request data (keep comment for code generation)
        _query: typing.Dict[str, QueryParamTypes] = {}
        if date is not None:
            _query["date"] = encode_query_param(date, False)
        if download_file_formats is not None:
            _query["download_file_formats"] = encode_query_param(
                download_file_formats, False
            )
        if exclude_child_message is not None:
            _query["exclude_child_message"] = encode_query_param(
                exclude_child_message, False
            )
        if from_query is not None:
            _query["from"] = encode_query_param(from_query, False)
        if include_deleted_and_edited_message is not None:
            _query["include_deleted_and_edited_message"] = encode_query_param(
                include_deleted_and_edited_message, False
            )
        if next_page_token is not None:
            _query["next_page_token"] = encode_query_param(next_page_token, False)
        if page_size is not None:
            _query["page_size"] = encode_query_param(page_size, False)
        if search_key is not None:
            _query["search_key"] = encode_query_param(search_key, False)
        if search_type is not None:
            _query["search_type"] = encode_query_param(search_type, False)
        if to is not None:
            _query["to"] = encode_query_param(to, False)
        if to_channel is not None:
            _query["to_channel"] = encode_query_param(to_channel, False)
        if to_contact is not None:
            _query["to_contact"] = encode_query_param(to_contact, False)
        # end -- build request data (keep comment for code generation)

        # start -- send sync request (keep comment for code generation)
        return self._client_wrapper.request(
            method="GET",
            path=f"/chat/users/{user_id}/messages",
            auth_names=["openapi_authorization", "openapi_oauth"],
            query_params=_query,
            cast_to=models.GetChatUsersUserIdMessagesResponse,
            request_options=request_options or default_request_options(),
        )
        # end -- send sync request (keep comment for code generation)

    def delete(
        self,
        *,
        user_id: str,
        message_id: str,
        to_channel: typing.Optional[str] = None,
        to_contact: typing.Optional[typing.Union[str, str, str]] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> None:
        """
        Deletes a chat message previously sent to a contact or a channel. For user-level apps, pass [the `me` value](https://marketplace.zoom.us/docs/api-reference/using-zoom-apis#mekeyword) instead of the `userId` parameter.

         For an [account-level OAuth app](https://marketplace.zoom.us/docs/guides/getting-started/app-types/create-oauth-app), this API can only be used on behalf of a user who is assigned with a [role](https://support.zoom.us/hc/en-us/articles/115001078646-Using-role-management) that has the **Edit** permission for **Chat Messages**.



        **Scopes:** `chat_message:write`,`chat_message:write:admin`

        **Granular Scopes:** `team_chat:delete:user_message`,`team_chat:delete:user_message:admin`

        **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Medium`
        """
        # start -- build request data (keep comment for code generation)
        _query: typing.Dict[str, QueryParamTypes] = {}
        if to_channel is not None:
            _query["to_channel"] = encode_query_param(to_channel, False)
        if to_contact is not None:
            _query["to_contact"] = encode_query_param(to_contact, False)
        # end -- build request data (keep comment for code generation)

        # start -- send sync request (keep comment for code generation)
        return self._client_wrapper.request(
            method="DELETE",
            path=f"/chat/users/{user_id}/messages/{message_id}",
            auth_names=["openapi_authorization", "openapi_oauth"],
            query_params=_query,
            cast_to=None,
            request_options=request_options or default_request_options(),
        )
        # end -- send sync request (keep comment for code generation)


class AsyncMessageClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper
        # register async resources (keep comment for code generation)

    # register async api methods (keep comment for code generation)
    async def update(
        self,
        *,
        data: typing.Optional[params.PutChatUsersUserIdMessagesMessageIdBody] = None,
        user_id: str,
        message_id: str,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> None:
        """
        Edits a chat message that you previously sent to either a contact or a channel in Zoom.

        It provides the ID of the message as the value of the `messageId` parameter. You can get the ID from the [List User's Chat Messages](https://developers.zoom.us/docs/api/rest/reference/chat/methods/#operation/getChatMessages) API. Additionally, as a query parameter, you must provide either the contact's **email address** of the contact or the **Channel ID** of the channel where the message was sent.

        For user-level apps, pass [the `me` value](https://marketplace.zoom.us/docs/api-reference/using-zoom-apis#mekeyword) instead of the `userId` parameter.

        **Note:** For an **account-level** [OAuth app](https://marketplace.zoom.us/docs/guides/getting-started/app-types/create-oauth-app), you can only use this API on behalf of a user who is assigned with a [role](https://support.zoom.us/hc/en-us/articles/115001078646-Using-role-management#:~:text=Each%20user%20in%20a%20Zoom,owner%2C%20administrator%2C%20or%20member.&amp;text=Role%2Dbased%20access%20control%20enables,needs%20to%20view%20or%20edit.) that has the **Edit** permission for **Chat Messages**.



        **Scopes:** `chat_message:write`,`chat_message:write:admin`

        **Granular Scopes:** `team_chat:update:user_message`,`team_chat:update:user_message:admin`

        **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `MEDIUM`
        """
        # start -- build request data (keep comment for code generation)
        _json = to_encodable(
            item=data,
            dump_with=params._SerializerPutChatUsersUserIdMessagesMessageIdBody,
        )
        # end -- build request data (keep comment for code generation)

        # start -- send async request (keep comment for code generation)
        return await self._client_wrapper.request(
            method="PUT",
            path=f"/chat/users/{user_id}/messages/{message_id}",
            auth_names=["openapi_authorization", "openapi_oauth"],
            json=_json,
            cast_to=None,
            request_options=request_options or default_request_options(),
        )
        # end -- send async request (keep comment for code generation)

    async def send(
        self,
        *,
        data: typing.Optional[params.PostChatUsersUserIdMessagesBody] = None,
        user_id: str,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> models.PostChatUsersUserIdMessagesResponse:
        """
        Sends chat messages to a user in your contact list or to a [channel](https://support.zoom.us/hc/en-us/articles/200912909-Getting-Started-With-Channels-Group-Messaging-) of which you are a member.
        For user-level apps, pass [the `me` value](https://marketplace.zoom.us/docs/api-reference/using-zoom-apis#mekeyword) instead of the `userId` parameter.

        - To send a message to a contact, provide the contact's email address in the `to_contact` field.
        - To send a message to a channel, provide the channel's ID in the `to_channel` parameter.



        **Scopes:** `chat_message:write`,`chat_message:write:admin`

        **Granular Scopes:** `team_chat:write:user_message`,`team_chat:write:user_message:admin`

        **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `MEDIUM`
        """
        # start -- build request data (keep comment for code generation)
        _json = to_encodable(
            item=data, dump_with=params._SerializerPostChatUsersUserIdMessagesBody
        )
        # end -- build request data (keep comment for code generation)

        # start -- send async request (keep comment for code generation)
        return await self._client_wrapper.request(
            method="POST",
            path=f"/chat/users/{user_id}/messages",
            auth_names=["openapi_authorization", "openapi_oauth"],
            json=_json,
            cast_to=models.PostChatUsersUserIdMessagesResponse,
            request_options=request_options or default_request_options(),
        )
        # end -- send async request (keep comment for code generation)

    async def mark_status(
        self,
        *,
        data: typing.Optional[
            params.PatchChatUsersUserIdMessagesMessageIdStatusBody
        ] = None,
        user_id: str,
        message_id: str,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> None:
        """
        Marks a chat message as read or unread. For user-level apps, pass [the `me` value](https://marketplace.zoom.us/docs/api-reference/using-zoom-apis#mekeyword) instead of the `userId` parameter.

        **Note:**

        For an [account-level OAuth app](https://marketplace.zoom.us/docs/guides/getting-started/app-types/create-oauth-app), this API can only be used on behalf of a [user assigned to a role](https://support.zoom.us/hc/en-us/articles/115001078646-Using-role-management) with the &quot;**Edit**&quot; permission for **Chat Messages**.



        **Scopes:** `chat_message:write`,`chat_message:write:admin`

        **Granular Scopes:** `team_chat:update:message_status`,`team_chat:update:message_status:admin`

        **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Medium`
        """
        # start -- build request data (keep comment for code generation)
        _json = to_encodable(
            item=data,
            dump_with=params._SerializerPatchChatUsersUserIdMessagesMessageIdStatusBody,
        )
        # end -- build request data (keep comment for code generation)

        # start -- send async request (keep comment for code generation)
        return await self._client_wrapper.request(
            method="PATCH",
            path=f"/chat/users/{user_id}/messages/{message_id}/status",
            auth_names=["openapi_authorization", "openapi_oauth"],
            json=_json,
            cast_to=None,
            request_options=request_options or default_request_options(),
        )
        # end -- send async request (keep comment for code generation)

    async def react(
        self,
        *,
        data: typing.Optional[
            params.PatchChatUsersUserIdMessagesMessageIdEmojiReactionsBody
        ] = None,
        user_id: str,
        message_id: str,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> None:
        """
        Adds or removes an emoji to a chat message.

        For an **account-level** [OAuth app](https://marketplace.zoom.us/docs/guides/getting-started/app-types/create-oauth-app), this API can only be used on behalf of a user who is assigned with a [role](https://support.zoom.us/hc/en-us/articles/115001078646-Using-role-management#:~:text=Each%20user%20in%20a%20Zoom,owner%2C%20administrator%2C%20or%20member.&amp;text=Role%2Dbased%20access%20control%20enables,needs%20to%20view%20or%20edit.) that has the **Edit** permission for **Chat Messages**.



        **Scopes:** `chat_message:write`,`chat_message:write:admin`

        **Granular Scopes:** `team_chat:update:message_emoji`,`team_chat:update:message_emoji:admin`

        **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Medium`
        """
        # start -- build request data (keep comment for code generation)
        _json = to_encodable(
            item=data,
            dump_with=params._SerializerPatchChatUsersUserIdMessagesMessageIdEmojiReactionsBody,
        )
        # end -- build request data (keep comment for code generation)

        # start -- send async request (keep comment for code generation)
        return await self._client_wrapper.request(
            method="PATCH",
            path=f"/chat/users/{user_id}/messages/{message_id}/emoji_reactions",
            auth_names=["openapi_authorization", "openapi_oauth"],
            json=_json,
            cast_to=None,
            request_options=request_options or default_request_options(),
        )
        # end -- send async request (keep comment for code generation)

    async def get_thread(
        self,
        *,
        user_id: str,
        message_id: str,
        from_query: str,
        limit: typing.Optional[int] = None,
        need_attachment: typing.Optional[bool] = None,
        need_emoji: typing.Optional[bool] = None,
        need_main_message: typing.Optional[bool] = None,
        sort: typing.Optional[typing_extensions.Literal["desc", "asc"]] = None,
        to: typing.Optional[str] = None,
        to_channel: typing.Optional[str] = None,
        to_contact: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> models.GetChatUsersUserIdMessagesMessageIdThreadResponse:
        """
        Retrieves all messages under a thread. For user-level apps, pass the `me` value instead of the `userId` parameter.

        **Scopes:** `chat_message:read`,`chat_message:read:admin`

        **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `MEDIUM`
        """
        # start -- build request data (keep comment for code generation)
        _query: typing.Dict[str, QueryParamTypes] = {}
        _query["from"] = encode_query_param(from_query, False)
        if limit is not None:
            _query["limit"] = encode_query_param(limit, False)
        if need_attachment is not None:
            _query["need_attachment"] = encode_query_param(need_attachment, False)
        if need_emoji is not None:
            _query["need_emoji"] = encode_query_param(need_emoji, False)
        if need_main_message is not None:
            _query["need_main_message"] = encode_query_param(need_main_message, False)
        if sort is not None:
            _query["sort"] = encode_query_param(sort, False)
        if to is not None:
            _query["to"] = encode_query_param(to, False)
        if to_channel is not None:
            _query["to_channel"] = encode_query_param(to_channel, False)
        if to_contact is not None:
            _query["to_contact"] = encode_query_param(to_contact, False)
        # end -- build request data (keep comment for code generation)

        # start -- send async request (keep comment for code generation)
        return await self._client_wrapper.request(
            method="GET",
            path=f"/chat/users/{user_id}/messages/{message_id}/thread",
            auth_names=["openapi_authorization", "openapi_oauth"],
            query_params=_query,
            cast_to=models.GetChatUsersUserIdMessagesMessageIdThreadResponse,
            request_options=request_options or default_request_options(),
        )
        # end -- send async request (keep comment for code generation)

    async def get(
        self,
        *,
        user_id: str,
        message_id: str,
        download_file_formats: typing.Optional[
            typing_extensions.Literal["audio/mp4"]
        ] = None,
        to_channel: typing.Optional[str] = None,
        to_contact: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> models.GetChatUsersUserIdMessagesMessageIdResponse:
        """
        Returns a chat message previously sent to a contact or a channel. For user-level apps, pass [the `me` value](https://marketplace.zoom.us/docs/api-reference/using-zoom-apis#mekeyword) instead of the `userId` parameter.

        You must provide one of the following query parameters:

        * `to_contact` &mdash; The email address of the Zoom contact to whom you sent the message.
        * `to_channel` &mdash; The ID of the Zoom channel where you sent the message.



        **Scopes:** `chat_message:write:admin`,`chat_message:read`,`chat_message:write`,`chat_message:read:admin`

        **Granular Scopes:** `team_chat:read:user_message`,`team_chat:read:user_message:admin`

        **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `MEDIUM`
        """
        # start -- build request data (keep comment for code generation)
        _query: typing.Dict[str, QueryParamTypes] = {}
        if download_file_formats is not None:
            _query["download_file_formats"] = encode_query_param(
                download_file_formats, False
            )
        if to_channel is not None:
            _query["to_channel"] = encode_query_param(to_channel, False)
        if to_contact is not None:
            _query["to_contact"] = encode_query_param(to_contact, False)
        # end -- build request data (keep comment for code generation)

        # start -- send async request (keep comment for code generation)
        return await self._client_wrapper.request(
            method="GET",
            path=f"/chat/users/{user_id}/messages/{message_id}",
            auth_names=["openapi_authorization", "openapi_oauth"],
            query_params=_query,
            cast_to=models.GetChatUsersUserIdMessagesMessageIdResponse,
            request_options=request_options or default_request_options(),
        )
        # end -- send async request (keep comment for code generation)

    async def list(
        self,
        *,
        user_id: str,
        date: typing.Optional[str] = None,
        download_file_formats: typing.Optional[
            typing_extensions.Literal["audio/mp4"]
        ] = None,
        exclude_child_message: typing.Optional[bool] = None,
        from_query: typing.Optional[str] = None,
        include_deleted_and_edited_message: typing.Optional[bool] = None,
        next_page_token: typing.Optional[str] = None,
        page_size: typing.Optional[int] = None,
        search_key: typing.Optional[str] = None,
        search_type: typing.Optional[
            typing_extensions.Literal["message", "file"]
        ] = None,
        to: typing.Optional[str] = None,
        to_channel: typing.Optional[str] = None,
        to_contact: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> models.GetChatUsersUserIdMessagesResponse:
        """
        Returns a list of chat messages and shared files between a user and an individual contact, or a chat channel. For user-level apps, pass [the `me` value](https://developers.zoom.us/docs/api/rest/using-zoom-apis/#the-me-keyword) instead of the `userId` parameter.

        **Note:** For an [account-level OAuth app](https://developers.zoom.us/docs/integrations/create/), this API can only be used on behalf of a [user assigned to a role](https://support.zoom.us/hc/en-us/articles/115001078646-Using-role-management) with the **Edit** permission for **Chat Messages**.



        **Scopes:** `chat_message:write:admin`,`chat_message:read`,`chat_message:write`,`chat_message:read:admin`

        **Granular Scopes:** `team_chat:read:list_user_messages`,`team_chat:read:list_user_messages:admin`

        **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `MEDIUM`
        """
        # start -- build request data (keep comment for code generation)
        _query: typing.Dict[str, QueryParamTypes] = {}
        if date is not None:
            _query["date"] = encode_query_param(date, False)
        if download_file_formats is not None:
            _query["download_file_formats"] = encode_query_param(
                download_file_formats, False
            )
        if exclude_child_message is not None:
            _query["exclude_child_message"] = encode_query_param(
                exclude_child_message, False
            )
        if from_query is not None:
            _query["from"] = encode_query_param(from_query, False)
        if include_deleted_and_edited_message is not None:
            _query["include_deleted_and_edited_message"] = encode_query_param(
                include_deleted_and_edited_message, False
            )
        if next_page_token is not None:
            _query["next_page_token"] = encode_query_param(next_page_token, False)
        if page_size is not None:
            _query["page_size"] = encode_query_param(page_size, False)
        if search_key is not None:
            _query["search_key"] = encode_query_param(search_key, False)
        if search_type is not None:
            _query["search_type"] = encode_query_param(search_type, False)
        if to is not None:
            _query["to"] = encode_query_param(to, False)
        if to_channel is not None:
            _query["to_channel"] = encode_query_param(to_channel, False)
        if to_contact is not None:
            _query["to_contact"] = encode_query_param(to_contact, False)
        # end -- build request data (keep comment for code generation)

        # start -- send async request (keep comment for code generation)
        return await self._client_wrapper.request(
            method="GET",
            path=f"/chat/users/{user_id}/messages",
            auth_names=["openapi_authorization", "openapi_oauth"],
            query_params=_query,
            cast_to=models.GetChatUsersUserIdMessagesResponse,
            request_options=request_options or default_request_options(),
        )
        # end -- send async request (keep comment for code generation)

    async def delete(
        self,
        *,
        user_id: str,
        message_id: str,
        to_channel: typing.Optional[str] = None,
        to_contact: typing.Optional[typing.Union[str, str, str]] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> None:
        """
        Deletes a chat message previously sent to a contact or a channel. For user-level apps, pass [the `me` value](https://marketplace.zoom.us/docs/api-reference/using-zoom-apis#mekeyword) instead of the `userId` parameter.

         For an [account-level OAuth app](https://marketplace.zoom.us/docs/guides/getting-started/app-types/create-oauth-app), this API can only be used on behalf of a user who is assigned with a [role](https://support.zoom.us/hc/en-us/articles/115001078646-Using-role-management) that has the **Edit** permission for **Chat Messages**.



        **Scopes:** `chat_message:write`,`chat_message:write:admin`

        **Granular Scopes:** `team_chat:delete:user_message`,`team_chat:delete:user_message:admin`

        **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Medium`
        """
        # start -- build request data (keep comment for code generation)
        _query: typing.Dict[str, QueryParamTypes] = {}
        if to_channel is not None:
            _query["to_channel"] = encode_query_param(to_channel, False)
        if to_contact is not None:
            _query["to_contact"] = encode_query_param(to_contact, False)
        # end -- build request data (keep comment for code generation)

        # start -- send async request (keep comment for code generation)
        return await self._client_wrapper.request(
            method="DELETE",
            path=f"/chat/users/{user_id}/messages/{message_id}",
            auth_names=["openapi_authorization", "openapi_oauth"],
            query_params=_query,
            cast_to=None,
            request_options=request_options or default_request_options(),
        )
        # end -- send async request (keep comment for code generation)
